# 详细设计(wj)



## 修改账户密码函数 (wj)
```cpp
所需要的传参：含头节点的链表的头指针
void RecorrectKey(BankListNode *head)
用于整个修改密码函数逻辑功能的实现

### 函数原型

```cpp
void RecorrectKey(BankListNode *head);
bool password_is_correct(BankListNode* target_Account, std::string Orginalpassword);
```

### 函数功能描述

#### 1. bool password_is_correct(BankListNode* target_Account, std::string Orginalpassword)

- **功能**：校验用户输入的原密码是否与目标账户当前密码一致，作为修改密码前的安全验证步骤。
- **参数**：
	- `target_Account`：指向目标账户结点的指针，包含该账户的完整信息。
	- `Orginalpassword`：用户输入的原密码字符串。
- **返回值**：
	- `true`：原密码正确，与账户当前密码一致；
	- `false`：原密码不正确。
- **主要处理逻辑**：
	1. 从 `target_Account->account.password` 中读取账户原有密码；
	2. 与 `Orginalpassword` 进行字符串比较；
	3. 若两者相等，返回 `true`，否则返回 `false`。

#### 2. void RecorrectKey(BankListNode *head)

- **功能**：提供“修改账户密码”的完整交互流程：
	- 先通过账户编号定位账户；
	- 再验证原密码；
	- 验证成功后修改为新密码。用户在输入过程中可以通过输入 `0` 退出操作。
- **参数**：
	- `head`：含头结点的账户链表头指针，用于在链表中查找指定账户。
- **返回值**：
	- 无（`void`）。密码修改结果直接体现在链表中对应账户结点的 `password` 字段被更新。
- **前置条件**：
	- 链表 `head` 已正确初始化；
	- 支持使用 `find_accountID(head, accountID)` 根据账户编号查找对应结点（找不到返回 `nullptr`）。
- **主要处理流程**：
	1. 提示用户输入要修改密码的账户编号 `temp_account`：
		 - 若输入为 `"0"`，直接退出函数；
		 - 调用 `find_accountID(head, temp_account)` 查找账户：
			 - 若返回 `nullptr`，提示“未找到该账户，请重新输入”，再次要求输入账户编号。
	2. 当找到目标账户后，提示用户输入原密码：
		 - 若用户输入 `"0"`，视为放弃本次修改操作，退出当前密码输入循环；
		 - 否则调用 `password_is_correct(target_Account, password)`：
			 - 若返回 `true`：
				 1. 提示用户输入新密码 `RecorrectPassword`；
				 2. 将 `find_accountID(head, temp_account)->account.password` 更新为新密码；
				 3. 通过标志位结束密码输入循环与外层账户编号循环；
			 - 若返回 `false`，提示“密码错误，请重新输入”，继续要求输入原密码。
	3. 当用户成功修改密码或主动退出（输入 `0`）后，函数结束。



## 排序(wj)

### 函数原型

```cpp
BankListNode* SortByName(BankListNode *head);
BankListNode* SortByMoney(BankListNode *head);
BankListNode* SortByAccount(BankListNode *head);
BankListNode* SortByDate(BankListNode *head);
void Sort(BankListNode *head);
void print_whole_account(BankListNode* head);
```

### 函数功能描述

#### 1. BankListNode* SortByName(BankListNode *head)

- **功能**：按开户人姓名对账户链表进行升序排序。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 返回排序后仍以 `head` 为头结点的链表头指针；
	- 若链表为空（`head->next == nullptr`），直接返回 `nullptr`。
- **主要处理逻辑**：
	1. 若链表为空，则返回 `nullptr`；
	2. 使用 `multiset<Account, NameCmp>` 容器，将从 `head->next` 起的所有账户信息按姓名比较规则插入容器；
	3. 再从链表 `head->next` 开始，按 `multiset` 中升序排列后的顺序依次回写到各结点的 `account` 字段，实现“按姓名排序”的稳定结果；
	4. 最终返回 `head`。

#### 2. BankListNode* SortByMoney(BankListNode *head)

- **功能**：按账户余额对账户链表进行升序排序。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 返回排序后仍以 `head` 为头结点的链表头指针；
	- 若链表为空（`head->next == nullptr`），直接返回 `nullptr`。
- **主要处理逻辑**：
	1. 若链表为空，则返回 `nullptr`；
	2. 使用 `multiset<Account, MoneyCmp>` 按余额比较规则存储所有账户；
	3. 将排序后的账户依次回写到链表中各结点，实现按余额升序排序；
	4. 最终返回 `head`。

#### 3. BankListNode* SortByAccount(BankListNode *head)

- **功能**：按账户编号对账户链表进行升序排序。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 返回排序后仍以 `head` 为头结点的链表头指针；
	- 若链表为空（`head->next == nullptr`），直接返回 `nullptr`。
- **主要处理逻辑**：
	1. 若链表为空，则返回 `nullptr`；
	2. 使用 `multiset<Account, AccountCmp>` 按账户编号比较规则插入所有账户；
	3. 将 `multiset` 中已按编号排序的 `Account` 依次写回链表结点；
	4. 最终返回 `head`。

#### 4. BankListNode* SortByDate(BankListNode *head)

- **功能**：按开户日期对账户链表进行升序排序（日期早的排在前面）。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 返回排序后仍以 `head` 为头结点的链表头指针；
	- 若链表为空（`head->next == nullptr`），直接返回 `nullptr`。
- **主要处理逻辑**：
	1. 若链表为空，则返回 `nullptr`；
	2. 使用 `multiset<Account, DateCmp>` 按开户日期比较规则存储所有账户；
	3. 将 `multiset` 中按日期排好序的账户信息依次回写链表；
	4. 最终返回 `head`。

#### 5. void Sort(BankListNode *head)

- **功能**：提供统一的“排序功能”菜单接口，根据用户选择的排序方式（账号 / 姓名 / 金额 / 开户日期）调用对应的排序函数，并输出排序结果。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 无（`void`）。排序结果直接反映在链表中账户结点的顺序和数据上。
- **主要处理流程**：
	1. 输出提示信息：“输入1为账户排序,2为开户人姓名排序,3为金额排序,4为开户日期排序,0为退出排序功能”；
	2. 读取用户输入的选项 `choice`：
		 - 若 `choice == "0"`，直接退出函数；
		 - 否则进入选项合法性检查循环：当 `choice` 不为 `1/2/3/4` 时，提示“没有这个选项,请重新输入”，并重新读取输入；
	3. 根据最终合法的 `choice`：
		 - `"1"`：调用 `SortByAccount(head)` 后调用 `print_whole_account(head)` 输出所有账户信息；
		 - `"2"`：调用 `SortByName(head)` 后输出全部账户；
		 - `"3"`：调用 `SortByMoney(head)` 后输出全部账户；
		 - `"4"`：调用 `SortByDate(head)` 后输出全部账户；
	4. 函数结束时，链表中账户顺序已根据用户选择的规则完成重排并打印展示。

#### 6. void print_whole_account(BankListNode* head)

- **功能**：从链表头结点后的第一个有效结点开始，依次遍历并输出所有账户的详细信息，用于展示排序结果或当前账户列表。
- **参数**：
	- `head`：含头结点的账户链表头指针。
- **返回值**：
	- 无（`void`）。仅负责将账户信息输出到终端。
- **主要处理逻辑**：
	1. 从 `head->next` 开始遍历链表直到末尾；
	2. 对每个结点依次输出：账户ID、姓名、性别（以“男/女”显示）、余额（以元为单位，`balance/100.0`）、开户日期、账户类型（“定期/活期”）；
	3. 每个账户信息块之间输出分隔线 `---------------------------` 方便阅读；
	4. 遍历结束后函数返回。





## 测试逻辑说明（wj）

### 1. 辅助函数设计

- `pushBack(BankListNode *&head, BankListNode *&tail, const Account &acc)`  
	- **功能**：在“无头结点”的单链表尾部追加一个账户结点，用于快速构造测试用账户链表。  
	- **逻辑**：
		1. 动态分配一个 `BankListNode`，填入传入的 `Account` 数据；
		2. 若当前链表为空（`head == nullptr`），同时更新 `head` 与 `tail` 为新结点；
		3. 否则将新结点挂在 `tail->next`，并更新 `tail` 指向新结点。

- `printList(const BankListNode *head)`  
	- **功能**：从给定结点开始依次打印每个账户的关键字段，用于观察排序和修改结果。  
	- **输出字段**：账号、姓名、余额（分）、开户日期（年-月-日）、类型（定期/活期）、密码。  
	- **说明**：这里的 `head` 是“数据链表首结点”，调用时从带头结点链表的 `head->next` 传入。

- `freeList(BankListNode *head)`  
	- **功能**：释放整条链表占用的堆内存，防止内存泄漏。  
	- **逻辑**：从 `head` 开始逐结点删除，直到链表结束。

### 2. 测试数据构造逻辑

- 在 `main` 中预先构造一个包含 10 个 `Account` 的数组 `testAccounts[10]`：  
	- 每个账户包含：账号、姓名、性别、密码、余额、开户日期、账户类型（定期/活期）；  
	- 刻意设置了不同的账号、姓名、余额、日期组合，方便测试多种排序规则。

- 链表构造步骤：  
	1. 创建一个头结点 `head`，仅用于链表管理，不存放有效账户数据（`head->next = nullptr`）；  
	2. 定义 `dataHead` 和 `tail`，先用 `pushBack` 在“无头结点链表”中依次插入 10 个测试账户；  
	3. 再将 `dataHead` 挂接到 `head->next`，形成“带头结点的账户链表”。

### 3. 排序功能测试流程

- **初始输出**：  
	- 打印提示 `"Hello, this is wj's sort test."`；  
	- 调用 `printList(head->next)` 输出“原始账户顺序”，用作对比基线。

- **调用排序入口**：  
	- 调用 `Sort(head)`：  
		- Sort 内部提示用户选择排序方式（账号 / 姓名 / 金额 / 开户日期 / 退出）；  
		- 根据用户输入调用对应的 `SortByAccount / SortByName / SortByMoney / SortByDate`，对 `head` 链表进行就地重排；  
		- 并调用 `print_whole_account(head)` 打印排序后的完整账户信息。

- **排序测试目的**：  
	- 通过用户选择不同排序方式，多次运行程序，人工对比：  
		- 排序前后账号顺序是否符合预期规则；  
		- 姓名、余额、日期排序是否正确稳定；  
		- 多条记录中有相同余额（等值）的情况是否表现正常。

### 4. 修改密码功能测试流程

- 在排序结束后，`main` 中调用 `RecorrectKey(head)`：  
	- **测试内容**：  
		1. 输入存在的账户编号，验证能正确找到账户；  
		2. 输入错误原密码时，程序能提示“密码错误”并要求重新输入；  
		3. 输入正确原密码后，能成功设置新密码；  
		4. 在输入账户编号或原密码时输入 `0`，能正常退出修改流程。

- **修改结果验证**：  
	- 再次调用 `printList(head->next)`：  
		- 检查对应账户的 `password` 字段是否已经更新为新密码；  
		- 其他账户字段（账号、余额、日期等）是否保持不变。

### 5. 资源回收逻辑

- 程序最后调用 `freeList(head)`：  
	- 释放从头结点开始的整条链表，确保单元测试结束后没有内存泄漏问题。




## Coding 过程中的问题与收获 (wj)

### 问题 1：链表排序算法与比较方式选择

- **问题描述**：
	- 在实现 `Sort` 函数时，需要对单链表中的账户按照不同字段排序（账号、姓名、金额、日期）。
	- 直接在链表上实现排序，比较复杂且容易出错；同时还需要一个“方便、可复用”的比较方式。
- **解决思路**：
	- 通过查阅资料，了解并学习了 `set` 容器的用法，最初尝试使用 `set + 自定义比较函数/仿函数` 来完成排序，将链表节点中的 `Account` 数据插入到有序容器中，由容器自动完成排序。
	- 在此基础上，设计了针对不同字段的比较结构体（如 `NameCmp`、`MoneyCmp` 等），实现了与排序字段解耦的比较逻辑。
- **收获与反思**：
	- 学会了利用 STL 容器简化链表排序问题，把“链表重排”转化为“将数据导入有序容器 + 回写链表”的思路。
	- 更加熟悉了比较仿函数（`operator()`）/ 自定义比较器在泛型算法和容器中的使用方式。

### 问题 2：`set` 不允许重复元素导致数据丢失

- **问题描述**：
	- 在使用 `set<Account, Cmp>` 进行排序时，发现当多个账户在排序字段上相同（如姓名相同、金额相同、开户日期相同）时，`set` 会因为“元素唯一性”要求而自动去重，导致部分账户数据在排序结果中被丢弃。
- **解决思路**：
	- 再次查阅文档与资料后，了解到 `multiset` 容器可以在有序的前提下允许“键值重复”；
	- 将原来的 `set` 全部替换为 `multiset`，并保持原有自定义比较器不变，使得在允许重复元素的情况下依然可以根据指定字段进行有序排列。
- **收获与反思**：
	- 深刻理解了 `set` 与 `multiset` 在“是否允许重复元素”上的重要区别；
	- 在之后设计数据结构与算法时，会优先考虑“数据特性”（是否有重复值）再选择合适的容器，而不是直接套用某一种容器。

### 问题 3：函数参数中是否包含头结点的统一问题

- **问题描述**：
	- 项目组前期对链表接口约定不够统一：有的函数传入“带头结点的链表”，有的函数传入“首节点即为第一个有效结点的链表”。
	- 我最初实现排序函数时，使用的是“不含头结点”的形式，但后期团队决定统一使用“含头结点的链表”，导致接口需要调整。
- **解决思路**：
	- 结合课程中对链表的讲解，重新梳理了“带头结点”和“无头结点”两种链表实现的差异；
	- 将排序相关函数统一改为接收“含头结点的链表头指针”，在函数内部从 `head->next` 开始处理数据节点；
	- 配合测试代码中的构造逻辑（先构造无头结点链表，再挂到 `head->next` 上），保证整体风格一致。
- **收获与反思**：
	- 进一步加深了对链表结构和头结点作用的理解；
	- 意识到在团队协作中，**统一接口与约定** 能显著减少后期修改成本。

### 问题 4：缺少现成 `main` 函数时如何设计测试

- **问题描述**：
	- 本人负责的模块主要是“功能函数”（排序、改密等），没有现成的 `main` 函数或完整业务流程可以直接用来测试；
	- 需要自己构思一套合理的测试逻辑与数据，验证各个函数的正确性和鲁棒性。
- **解决思路**：
	- 借助 AI 辅助思考测试用例与测试框架的搭建方式，设计了独立的 `test-wj.cpp`；
	- 构造了 10 条具有代表性差异（账号、姓名、金额、开户日期、账户类型各不相同或部分相同）的账户数据；
	- 通过多次运行程序、选择不同排序方式，并设计部分“极端/边界数据”（如金额相同、日期相同等），来观察排序结果和密码修改流程是否符合预期。
- **收获与反思**：
	- 学会了在没有现成业务场景时，主动为函数设计“最小可行测试环境”的思路；
	- 体验到合理使用 AI 工具可以提高测试设计效率，但最终仍需要自己理解并检查测试是否覆盖了关键逻辑与边界情况。

### 问题 5：交互输入输出逻辑与用户体验

- **问题描述**：
	- 在设计排序菜单、修改密码等交互流程时，需要避免用户被困在死循环（如一直输错、无法返回上一级菜单）；
	- 同时希望交互提示尽量清晰、友好，让用户知道当前可以做什么、如何退出。
- **解决思路**：
	- 在多个功能中统一约定：输入 `0` 表示“返回上一级 / 退出当前功能”，并在提示语中明确说明；
	- 对非法输入（例如排序菜单中不是 `1/2/3/4/0` 的情况）给出明确错误提示，并引导用户重新输入，而不是直接退出程序；
	- 在密码修改流程中，既允许多次尝试，又保证用户随时可以通过输入 `0` 放弃当前操作。
- **收获与反思**：
	- 逐渐从“只让程序跑通”转变为从**用户视角**思考交互设计；
	- 认识到良好的输入输出设计可以显著提升系统的易用性和鲁棒性。

### 问题 6：对 Git 工具和多人协作流程的不熟悉

- **问题描述**：
	- 刚开始接触 Git 与分支协作时，对“拉取他人代码”“查看历史”“合并分支”等操作不熟悉；
	- 在与队友协作时，担心自己的提交会覆盖或破坏他人代码，影响整体进度。
- **解决思路**：
	- 在同学和队友的帮助下，初步掌握了 Git 的基本流程：
		- 如何从远程仓库拉取最新代码；
		- 如何在自己的分支上开发和提交；
		- 如何查看他人提交、学习他人实现思路；
		- 如何将自己的分支合并到主分支，并在冲突时进行简单的解决。
- **收获与反思**：
	- 对 Git 这一协作工具有了更直观的认识，也更加理解“版本控制”在团队项目中的重要性；
	- 在之后的开发中，会主动使用分支、提交信息等方式记录自己的工作，方便团队协作和后续维护。
### 问题 7：main函数测试时，发现我未处理带有空格的账号与密码

- **问题描述**：
	- 输入没有考虑到带有空格的账号与密码输入；
- **解决思路**：
	- 将cin改为getline。
- **收获与反思**：
	- 对代码逻辑的严谨有进一步的思考；